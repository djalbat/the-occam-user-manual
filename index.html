<!DOCTYPE html>
<html>
  <head>
    <title>The Foundations of Symbolic Reasoning</title>
    
    <style>

      *,
      *::after,
      *::before {
        border: 0;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
    
    </style>
    <style>

div {
  color: black;
  padding: 12pt;
  min-height: 100%;
  font-family: "Computer Modern Serif";
  background-color: white;
}

div h1 {
  font-size: 32pt;
  margin: 12pt 0 12pt 0;
}

div h2 {
  font-size: 24pt;
  margin: 12pt 0 12pt 0;
}

div h3 {
  font-size: 16pt;
  margin: 12pt 0 12pt 0;
}

div table,
div p,
div ol,
div ul,
div pre.block,
div h4 {
  font-size: 12pt;
  line-height: 15pt;
  margin: 12pt 0 12pt 0;
}

div ol > li,
div ul > li {
  margin: 6pt 0 6pt 0;
  margin-left: 12pt;
}

div table:first-child,
div p:first-child,
div ol:first-child,
div ul:first-child,
div ol > li:first-child,
div ul > li:first-child,
div pre.block:first-child,
div h1:first-child,
div h2:first-child,
div h3:first-child,
div h4:first-child {
  margin-top: 0;
}

div table:last-child,
div p:last-child,
div ol:last-child,
div ul:last-child,
div ol > li:last-child,
div ul > li:last-child,
div pre.block:last-child,
div h1:last-child,
div h2:last-child,
div h3:last-child,
div h4:last-child {
  margin-bottom: 0;
}

div h1,
div h2,
div h3,
div h4 {
  font-weight: bold;
}

div pre.block,
div pre.inline {
  color: white;
  background-color: black;
  font-family: "Computer Modern Typewriter";
}

div pre.block {
  padding: 6pt;
  overflow-x: scroll;
}

div pre.inline {
  display: inline-block;
  padding: 0 3pt 0 3pt;
  font-size: 12pt;
  line-height: 15pt;
}

div table {
  border-collapsed: collapse;
}

div thead {
  border: 1pt solid black;
}

div td,
div th {
  padding: 12pt;
}

div strong {
  font-weight: bold;
}

div em {
  font-style: italic;
}

div em > strong {
  font-style: italic;
  font-weight: bold;
}

div ol.footnotes {
  border-top: 1pt solid black;
  padding-top: 12pt;
}

div li.footnote {
  font-size: 9pt;
  line-height: 12pt;
  margin-left: 12pt;
}

div li.footnote p {
  margin: 0;
  font-size: 9pt;
  line-height: 12pt;
}

div a.link {
  font-size: 9pt;
  line-height: 12pt;
  margin-left: 3pt;
  vertical-align: super;
}

div span.error {
  text-decoration: underline red;
}

div#README {
  font-size: 12pt;
  font-family: Arial;
}

div#README h1,
div#README h2 {
  color: #1f2328;
  margin-top: 18pt;
  margin-bottom: 12pt;
  border-bottom: 1pt solid #d0D7de;
}

div#README h1:first-child,
div#README h2:first-child {
  margin-top: 0;
}

div#README h1 {
  font-size: 24pt;
  padding-bottom: 12pt;
}

div#README h2 {
  font-size: 18pt;
  padding-bottom: 8pt;
}

div#README ul {
  padding-left: 18pt;
  margin-bottom: 12pt;
}

div#README ul > li {
  margin-top: 3pt;
}

div#README a {
  color: #0969da;
}

div#cover {
  padding: 0;
  padding-top: 64pt;
  background-color: #f5f4ed;
}

div#cover img {
  width: 100%;
  height: auto;
  border: 2pt solid #0a0d0b;
  display: block;
  padding: 24pt 0 24pt 0;
  border-left: none;
  border-right: none;
}

div#cover h1,
div#cover h2 {
  color: #0a0d0b;
  text-align: center;
  font-weight: normal;
  margin-left: auto;
  margin-right: auto;
  text-transform: uppercase;
}

div#cover h1 {
  width: 320pt;
  border: 4pt solid #0a0d0b;
  font-size: 40pt;
  border-left: none;
  border-right: none;
}

div#cover h2 {
  font-size: 24pt;
}

div#cover h2:last-child {
  margin-top: 32pt;
}

div {
  padding: 24pt;
}

div pre.block,
div pre.inline {
  color: #000;
  background-color: #eee;
}

div#dedication {
  padding: 0;
}

div#dedication p {
  width: fit-content;
  font-size: 18pt;
  padding-top: 160pt;
  margin-left: auto;
  margin-right: auto;
}

div#half-title {
  padding: 0;
  padding-top: 96pt;
}

div#half-title img {
  width: 100%;
  height: auto;
  border: 2pt solid #0a0d0b;
  display: block;
  padding: 18pt 0 18pt 0;
  border-left: none;
  border-right: none;
}

div#half-title h1,
div#half-title h2 {
  text-align: center;
  font-weight: normal;
  margin-left: auto;
  margin-right: auto;
  text-transform: uppercase;
}

div#half-title h1 {
  width: 240pt;
  border: 3pt solid #0a0d0b;
  font-size: 30pt;
  border-left: none;
  border-right: none;
}

div#half-title h2 {
  font-size: 18pt;
}

div#half-title h2:last-child {
  margin-top: 32pt;
}



    </style>
  </head>
  <body>

  <div>
    <div id="cover">
      <h1>
        <span class="line">
 The Occam <img src="/image/occam.svg">Logo</img> User Manual
        </span>
      </h1>
      <h2>
        <span class="line">
 James Smith
        </span>
      </h2>
    </div>
    <div id="front-matter">
      <div id="half-title">
        <h1>
          <span class="line">
 The Occam <img src="/image/occam-half.svg">Logo</img> User Manual
          </span>
        </h1>
        <h2>
          <span class="line">
 James Smith
          </span>
        </h2>
      </div>
      <div id="dedication">
        <p>
          <span class="line">
For Killy
          </span>
        </p>
      </div>
      <div id="table-of-contents">
        <ul>
          <li>
            <span class="line">
 [Introduction](./introduction.md)
            </span>
          </li>
          <li>
            <span class="line">
 [Getting started](./getting-started.md)
            </span>
          </li>
          <li>
            <span class="line">
 [Getting to grips with the IDE](./getting-to-grips-with-the-ide.md)
            </span>
          </li>
          <li>
            <span class="line">
 [Understanding Grammars](./understanding-grammars.md)
            </span>
          </li>
        </ul>
      </div>
    </div>
    <div id="introduction">
      <h1>
        <span class="line">
 Introduction
        </span>
      </h1>
      <p>
        <span class="line">
I have tried to make Occam<a class="link" href="#occam">1</a> as useable as possible but there are limits.
        </span>
        <span class="line">
At the end of the day it is an expert system and some of its parts, not least the verifier, need detailed explanation.
        </span>
        <span class="line">
It is the purpose of this book is to provide these explanations.
        </span>
      </p>
      <p>
        <span class="line">
This book also goes into considerable detail on the subject of Occam's approach to language, which largely boils down to its use of grammars.
        </span>
        <span class="line">
Occam has what might be called a default language or vernacular, called Florence,<a class="link" href="#florence">2</a> but it will also support controlled natural languages in the near future.
        </span>
        <span class="line">
Indeed, the verifier cannot distinguish between these languages at all.
        </span>
        <span class="line">
This book explains how this is possible.
        </span>
      </p>
      <p>
        <span class="line">
After explaining Occam's approach to language this book gives a very detailed explanation of how the verifier works.
        </span>
        <span class="line">
Some may find this nauseating but I maintain that it is essential.
        </span>
        <span class="line">
The whole idea behind Occam is to facilitate human reasoning and not to supplant it, and it is the verifier that reasons on your behalf.
        </span>
        <span class="line">
So you must understand how it works.
        </span>
        <span class="line">
In fact I recommend that you read the introduction together with the first four chapters of the Foundations book before going much further with this one.
        </span>
        <span class="line">
They are neither very long nor very deep and will provide the necessary background for understanding the verifier in particular.
        </span>
      </p>
      <p>
        <span class="line">
I hope that the verifier's implenentation is both transparent and readable, and therefore understandable, especially augmented as it is with the explanation here.
        </span>
        <span class="line">
Apart from anything else even a partial understanding will likely save a good deal of frustration when you begin to work seriously with Occam.
        </span>
        <span class="line">
The other reason for understanding the verifier is that it has not been verified itself.
        </span>
        <span class="line">
So you cannot simply press a button and have confidence in it, that is not the idea at all.
        </span>
      </p>
      <p>
        <span class="line">
In fact, at the risk of courting controversy, I would argue that it should not be the idea with any verifier.
        </span>
        <span class="line">
All are failible regardless of what their proponents may claim and therefore I do not believe that their results should ever be trusted without some level of human oversight.
        </span>
        <span class="line">
Indeed in my opinion verification should be an aid to clarity and rigour and never a substitute for it.
        </span>
        <span class="line">
The idea of a proof as a black box in particular is anathema to me.
        </span>
      </p>
      <p>
        <span class="line">
Moving on, the standpoint that software should be an aid to human reasonibg and not a substitute for it must these days be tempered by a consideration of artificial intelligence as a tool for reasoning.
        </span>
        <span class="line">
What inspired me over the near decade of work that it took to get Occam to its first viable release was a firm belief in what I call the four elephants, expounded in the aforementtioned first four chapters of the Foundations book.
        </span>
        <span class="line">
I had not heard of large language models when I started out and they were never a motivating factor, but as I came to my first milestone after those many years, they began to loom large.
        </span>
      </p>
      <p>
        <span class="line">
The resurgence of artificial intelligence in recent years has hardly changed my view on the relationship between software and humans apropos of reasoning, however.
        </span>
        <span class="line">
Admittedly of late there has been some progress in the direction of coupling artificial intelligence models with formal reasoning systems.
        </span>
        <span class="line">
For its part Occam only has a bearing on the right hand side of this coupling, so to speak.
        </span>
        <span class="line">
It is much more flexible and extensible than systems where inference rules are hard-coded, however.
        </span>
        <span class="line">
Moreover on the left hand side, so to speak, the output of potentially any large language model or such like can serve as input for Occam.
        </span>
      </p>
      <p>
        <span class="line">
Thus the panacea of using computers as tools for symbolic reasoning, be that devising algorithms or protocols; discovering new mathematics or logic; or whatever, is almost upon us.
        </span>
        <span class="line">
And it is worth pointing out that this panacea has been eagerly anticipated for around seventy five years now.
        </span>
        <span class="line">
There is no doubt that artificial intelligence is on the verge of bringing of all this about, but without tools such as Occam the output of artificial intelligence models will always be clouded in doubt.
        </span>
      </p>
      <p>
        <span class="line">
I hope and expect Occam to become an indespensible tool for at least some of those working in a field of symbolic reasoning in the coming years.
        </span>
        <span class="line">
Amongst other things it will enable them to leverage artificial intelligence to aid their own enquiries but artificial intelligence will not, at least not in the foreseeable future, supplant them.
        </span>
      </p>
      <ol class="footnotes">
        <li class="footnote">
          <a class="anchor" id="occam"/>
          <p>
            <span class="line">
 The word Occam is used somewhat nebulously here.
            </span>
            <span class="line">
It is most often associated with Occam's IDE but in fact it encompasses a range of software and services.
            </span>
            <span class="line">
This book explains these divers parts and there is a companion book, called The Foundations of Symbolic Reasoning, that covers the underlying theory.
            </span>
          </p>
        </li>
        <li class="footnote">
          <a class="anchor" id="florence"/>
          <p>
            <span class="line">
 Occam was originally called Florence but the former seemed more apt.
            </span>
          </p>
        </li>
      </ol>
    </div>
    <div id="getting-started">
      <h1>
        <span class="line">
 Getting started
        </span>
      </h1>
      <p>
        <span class="line">
Occam comprises divers sites, services and applications, the documentation for which is somewhat disparate.
        </span>
        <span class="line">
This chapter aims to bring it all together.
        </span>
        <span class="line">
It also provices some background on the tools and technologies behind Occam, for the curious.
        </span>
      </p>
      <p>
        <span class="line">
All of Occam is written in JavaScript, which was invented in the mid-nineties. 
        </span>
        <span class="line">
It could be said to have languished until the advent of Node.js, hereafter called just Node, in the late naughties.
        </span>
        <span class="line">
Node brought several innovations:
        </span>
      </p>
      <ul>
        <li>
          <span class="line">
 It enabled developers to write web application servers almost almost trivially.
          </span>
        </li>
        <li>
          <span class="line">
 It provided a straightforward package manager and a site where packages could be published for free and for all of the community to use.
          </span>
        </li>
        <li>
          <span class="line">
 As well as server side code, developers could write client side code on Node which could be made to run on browsers by way of a process called bundling.
          </span>
        </li>
      </ul>
      <p>
        <span class="line">
Allied with continued improvements to JavaScript itself, most notably the ES6 and ES7 releases, Node resulted in an explosion in its use.
        </span>
        <span class="line">
This was especially evidient in, but by no means restricted to, Internet appcliations.
        </span>
        <span class="line">
Both JavaScript and Node continue to evolve and although both have their detractors, it is safe to say that they will be with us and in a healthy state for the foreseeable future.
        </span>
      </p>
      <h2>
        <span class="line">
 Prerequisites
        </span>
      </h2>
      <p>
        <span class="line">
It almost goes without saying then that in order to use Occam you will need to have Node installed.
        </span>
        <span class="line">
In fact the chances are that it already is.
        </span>
        <span class="line">
To check this, run the following command in a terminal or command prompt:
        </span>
      </p>
      <pre class="block">
node --version
      </pre>
      <p>
        <span class="line">
If something like the following is returned...
        </span>
      </p>
      <pre class="block">
v18.16.1
      </pre>
      <p>
        <span class="line">
...then you are in good shape and need do nothing more.
        </span>
        <span class="line">
Any major version of Node will do to run Occam, down to major version 12.
        </span>
        <span class="line">
If the version that you have installed is older than that or if you just want to install the latest version then go to the Node site here...
        </span>
      </p>
      <p>
        <span class="line">
<a href="https://nodejs.org">https://nodejs.org</a>
        </span>
      </p>
      <p>
        <span class="line">
...and follow the instructions for your operating system.
        </span>
      </p>
      <p>
        <span class="line">
Installing Node will also install Node's package manager, called <pre class="inline">npm</pre>.
        </span>
        <span class="line">
Again you can easily check that it is installed with the following command:
        </span>
      </p>
      <pre class="block">
npm --version
      </pre>
      <p>
        <span class="line">
If you have a relatively recent version of Node installed then the version of <pre class="inline">npm</pre> will also be recent enough, too.
        </span>
      </p>
      <p>
        <span class="line">
The only other prerequisite is Git.
        </span>
        <span class="line">
Git is version control software invented by Linus Torvalds, of Linux fame.
        </span>
        <span class="line">
It revolutionised version control almost instantly upon its release and, as a consequence, revolutionised developer and team workflows.
        </span>
        <span class="line">
Alongside Git came the GitHub website.
        </span>
        <span class="line">
GitHub enabled developers to share their code with the wider community and, as an aside, along with Markdown it brought readme files to the fore.
        </span>
        <span class="line">
You can at a pinch get away without installing Git, at least initially, but if you are going to do any serious work with Occam then you will need it.
        </span>
        <span class="line">
Occam's own package manager leverages Git, for example, and the Open Mathematics site allows for GitHub integration.
        </span>
      </p>
      <p>
        <span class="line">
Git may well already be installed on your system.
        </span>
        <span class="line">
In order to check, run the following command:
        </span>
      </p>
      <pre class="block">
git --version
      </pre>
      <p>
        <span class="line">
Any version will do since Git has been more than adequate since its initial release.
        </span>
        <span class="line">
If you do not have Git installed or want the latest version then go to the Git website:
        </span>
      </p>
      <p>
        <span class="line">
<a href="https://git-scm.com">https://git-scm.com</a>
        </span>
      </p>
      <p>
        <span class="line">
Installation should be straightforward and no further guidance is given here.
        </span>
      </p>
      <h2>
        <span class="line">
 Installing the IDE
        </span>
      </h2>
      <p>
        <span class="line">
Occam has its own IDE, or integrated development environment.
        </span>
        <span class="line">
There are two variants available, for desktop and browser.
        </span>
        <span class="line">
The desktop variant currently only runs on MacOS and the browser variant is therefore provided for everyone else.
        </span>
        <span class="line">
You must use Google Chrome in order to run it, however.
        </span>
        <span class="line">
Other browsers may work but they are not supported.
        </span>
        <span class="line">
If you really have an issue with Chrome then use Chromium which, although still Google's, is at least open source:
        </span>
      </p>
      <p>
        <span class="line">
<a href="https://www.chromium.org/home">https://www.chromium.org/home</a>
        </span>
      </p>
      <p>
        <span class="line">
It is worth mentioning that there is effectively no difference between the two variants and you are not missing out if you can only install the browser variant.
        </span>
        <span class="line">
The desktop variant is in fact simply the aforementioned Chromium configured so as to hide the usual browser functionality and present only the embedded application.
        </span>
        <span class="line">
If you get the chance to run the two variants side by side then will be able to see for yourself that they are identical.
        </span>
      </p>
      <p>
        <span class="line">
Both variants are available from the Occam website:
        </span>
      </p>
      <p>
        <span class="line">
<a href="https://occam.science">https://occam.science</a>
        </span>
      </p>
      <p>
        <span class="line">
Click on the 'I am not a robot' checkbox and download your preference.
        </span>
      </p>
      <p>
        <span class="line">
Installing the browser variant will be covered first.
        </span>
        <span class="line">
Simply unzip the downloaded zip file and move the unzipped 'Occam' directory to a location of your choice.
        </span>
        <span class="line">
Your home directory is advised but it does not really matter as long as you have access to the directory from a terminal or command prompt.
        </span>
        <span class="line">
Now open a terminal or command prompt, <pre class="inline">cd</pre> into the Occam directory and execute the following command:
        </span>
      </p>
      <pre class="block">
npm start
      </pre>
      <p>
        <span class="line">
Lastly, open a browser with the following URL:
        </span>
      </p>
      <p>
        <span class="line">
[http://localhost:8888](http://localhost:8888)
        </span>
      </p>
      <p>
        <span class="line">
You will be presented with the Occam IDE.
        </span>
        <span class="line">
Beyond bookmarking the URL there is nothing more to do.
        </span>
      </p>
      <p>
        <span class="line">
To install the desktop variant, again unzip the downloaded zip file and this time drag it into the Applications directory, which should be accessible from the finder.
        </span>
        <span class="line">
Now, most importantly, do not double click on the icon.
        </span>
        <span class="line">
Instead, right click on it and choose 'Open'.
        </span>
        <span class="line">
Doing this ensures that you have the opportunity to configure MacOS to execute the iDE even though it is not from a trusted source.
        </span>
        <span class="line">
If you simply go ahead and double click on the icon then you will have to configure the security settings after the event and this can be fiddlesome to say the least.
        </span>
        <span class="line">
Once the IDE is running, right click on the icon in the dock and choose the option to keep it there.
        </span>
      </p>
      <p>
        <span class="line">
One last thing to bear in mind is that opening more than one instance of either the browser or indeed the desktop variant of the IDE will almost certainly lead to problems and possibly even lost work.
        </span>
        <span class="line">
This is because the IDE stores its settings in the browser's local storage, remember that the desktop version is really just a browser in disguise, and this storage is shared across instances.
        </span>
        <span class="line">
If you have two instances and change the projects directory in one of them, for example, you will effectivley be changing it in the other.
        </span>
        <span class="line">
Perhaps the settings can be sandboxed to particular instances in some later release but this is not the case presently so beware.
        </span>
      </p>
      <h2>
        <span class="line">
 Installing the CLI tools
        </span>
      </h2>
      <p>
        <span class="line">
CLI stands for command line interface and CLI tools are the ones that do not have a GUI, instead running directly inside a terminal or command prompt.
        </span>
        <span class="line">
Occam has two, namely a package manager and called <pre class="inline">open</pre>; and a verifier called simply <pre class="inline">verify</pre>.
        </span>
        <span class="line">
Installing them both is done by way of <pre class="inline">npm</pre> and is easy enough, although there are caveats.
        </span>
      </p>
      <p>
        <span class="line">
The first caveat is that if you are using a unixy operating system, and this includes MacOS, then you will probably need to prepend <pre class="inline">sudo</pre> to the installation commands.
        </span>
        <span class="line">
The reason for this is that the tools are installed globally and the directory for globally installed npm packages, is restricted.
        </span>
        <span class="line">
Prepending <pre class="inline">sudo</pre> to the install commands therefore ensures that the installation can go ahead.
        </span>
        <span class="line">
There is an argument that says that you should not use such a directory and instructions can be found on the Internet to configure <pre class="inline">npm</pre> to use others.
        </span>
        <span class="line">
However, in all honesty, if you trust the package in question then it is not worth the bother.
        </span>
        <span class="line">
It is far easier to just prepend <pre class="inline">sudo</pre> and have done with it.
        </span>
      </p>
      <p>
        <span class="line">
Moving on, in order to install the <pre class="inline">open</pre> package manager execute the following command in a terminal or command prompt, leaving off the <pre class="inline">sudo</pre> as necessary:
        </span>
      </p>
      <pre class="block">
sudo npm install --global occam-open-cli@latest
      </pre>
      <p>
        <span class="line">
Similarly for the verifier:
        </span>
      </p>
      <pre class="block">
sudo npm install --global occam-verify-cli@latest
      </pre>
      <p>
        <span class="line">
You can immediately check that the verifier is installed by running the following command:
        </span>
      </p>
      <pre class="block">
verify --version
      </pre>
      <p>
        <span class="line">
You should see something like this:
        </span>
      </p>
      <pre class="block">
Occam Verify-CLI version 0.0.645
      </pre>
      <p>
        <span class="line">
You can also try the <pre class="inline">open</pre> package manager with the following command:
        </span>
      </p>
      <pre class="block">
open --version
      </pre>
      <p>
        <span class="line">
And you may, if you are fortunate, see something like this:
        </span>
      </p>
      <pre class="block">
Occam Open-CLI version 6.0.9
      </pre>
      <p>
        <span class="line">
If you do then you can safely skip to the next section.
        </span>
        <span class="line">
Otherwise if you see an error then the second caveat applies to you and you will have to read on.
        </span>
      </p>
      <p>
        <span class="line">
An error occurs when there is another application called <pre class="inline">open</pre> that takes precedence over the <pre class="inline">open</pre> npm package that you have just installed.
        </span>
        <span class="line">
One workaround, therefore, is to create a symbolic link to the package that ensures it takes precedence.
        </span>
        <span class="line">
This may render the other application useless, however in practice this is rarely an issue.
        </span>
        <span class="line">
It is, however, worth just mentioning what kinds of applications are likely to be pushed aside, so to speak, by this workaround.
        </span>
        <span class="line">
In the case of MacOS the <pre class="inline">open</pre> CLI tool can be used to open files with their registered applications.
        </span>
        <span class="line">
For example, you could open a PDF file with the system's default PUF viewer.
        </span>
        <span class="line">
On other unixy systems the <pre class="inline">open</pre> application is likely to be a legacy graphics utility.
        </span>
        <span class="line">
In either case pushing it aside will do no lasting harm.
        </span>
      </p>
      <p>
        <span class="line">
To continue, in order to create a symbolic link you first need to know the fully qualified path to the npm global installation directory.
        </span>
        <span class="line">
This is easily recovered as the first line of the output from the following command:
        </span>
      </p>
      <pre class="block">
npm list --global
      </pre>
      <p>
        <span class="line">
Once you have the directory to hand, you need to add an alias to your terminal or command promopt's configuration file.
        </span>
        <span class="line">
Exactly what this file is depends on your system.
        </span>
        <span class="line">
On MacOS it will be either the <pre class="inline">.bashrc</pre> or <pre class="inline">.bash_profile</pre> file in your home directory.
        </span>
        <span class="line">
If you are not using MacOS then hopefully you will have enough knowledge of your system to know which file to edit.
        </span>
        <span class="line">
Moving swiftly on, assuming that the fully qualified path of the npm global installation directory is <pre class="inline">/usr/local/bin</pre>, add the following line to the requisite terminal or command prompt configuration file:
        </span>
      </p>
      <pre class="block">
alias open='/usr/local/lib/node_modules/occam-open-cli/open.js'
      </pre>
      <p>
        <span class="line">
Obviously adjust this to match your own npm global installation directory.
        </span>
        <span class="line">
Save the file and if you open a new terminal or command prompt then the <pre class="inline">open</pre> package manager should now be ready to use.
        </span>
      </p>
      <p>
        <span class="line">
With hindsight perhaps <pre class="inline">open</pre> was not the best name to choose for Occam's package manager.
        </span>
        <span class="line">
Hopefully the above workaround has not caused too many difficulties.
        </span>
      </p>
      <h2>
        <span class="line">
 Opening, viewing and verifying packages and projects
        </span>
      </h2>
      <p>
        <span class="line">
With the IDE and <pre class="inline">open</pre> package manager to hand you are ready to start looking at some Occam packages and projects.
        </span>
        <span class="line">
To begin with, create a projects directory.
        </span>
        <span class="line">
You can call it what you like but here it will be called 'Projects'.
        </span>
        <span class="line">
By the way, projects and packages tend to sit side by side in the same diretory with Occam.
        </span>
        <span class="line">
To continue, when you have created the projects directory, open a terminal or command prompt and <pre class="inline">cd</pre> into it:
        </span>
      </p>
      <pre class="block">
cd Projects
      </pre>
      <p>
        <span class="line">
Then initialise the <pre class="inline">open</pre> package manager with the following command:
        </span>
      </p>
      <pre class="block">
open initialise
      </pre>
      <p>
        <span class="line">
This creates a hidden configuration file which under normal circumstances you should not need to touch.
        </span>
      </p>
      <p>
        <span class="line">
Next, open some packages with the following command:
        </span>
      </p>
      <pre class="block">
open material-conditional
      </pre>
      <p>
        <span class="line">
Several packages will be opened, in fact, the last of which will be the <pre class="inline">material-conditional</pre> package.
        </span>
        <span class="line">
Next, in order to find out the fully qualified path of the projects directory use the following command, which stands for present working dfirectory:
        </span>
      </p>
      <pre class="block">
pwd
      </pre>
      <p>
        <span class="line">
Make a note of the fully qualified path and launch the IDE.
        </span>
        <span class="line">
Near to the top left you will see a projects path input field.
        </span>
        <span class="line">
Type in the fully qualified path of the projects directory and hit return or click on the refresh button immediately to the right of the input field.
        </span>
        <span class="line">
You will see the packages appear in the projects pane on the left.
        </span>
        <span class="line">
Note the small padlocks on the folder icons, which tell you that these are packages and not project directories.
        </span>
        <span class="line">
It is perhaps not worth going into too much detail in this chapter about what the various files and directories contain, but do at least take a few moments to click around, so to speak.
        </span>
        <span class="line">
One thing you will notice is that all of the files are read only.
        </span>
        <span class="line">
This is to be expected given that these are packages and not projects.
        </span>
      </p>
      <p>
        <span class="line">
Before opening any projects, delete the existing packages.
        </span>
        <span class="line">
In order to do so, from within the projects directory run the following command if you are on Windows...
        </span>
      </p>
      <pre class="block">
del /S *
      </pre>
      <p>
        <span class="line">
...or the followinog command if you are on unixy systems:
        </span>
      </p>
      <pre class="block">
rm -rf *
      </pre>
      <p>
        <span class="line">
Double check that all of the packages have been removed by returning to the IDE and clicking the refresh button.
        </span>
      </p>
      <p>
        <span class="line">
Now run the following command in the projects directory:
        </span>
      </p>
      <pre class="block">
open clone peano-axioms
      </pre>
      <p>
        <span class="line">
This time you will be prompted to clone all of the depdencies.
        </span>
        <span class="line">
If you type 'y' and hit return then <pre class="inline">open</pre> will clone the underlying projects for the packages rather than just downloading the packages themselves.
        </span>
        <span class="line">
It leverages Git in order to do this, which is why you need Git installed even at this relatively early stage.
        </span>
        <span class="line">
Return to the IDE and click the refresh button again.
        </span>
        <span class="line">
You will see the newly created project directories, without padlocks this time.
        </span>
        <span class="line">
You will also note that all of the files are editable.
        </span>
      </p>
      <p>
        <span class="line">
Lastly, have a go at verifying the <pre class="inline">peano-axioms</pre> project.
        </span>
        <span class="line">
Because it has already been published and because you have downloaded all of the dependencies as well as the project itself, it should verify without a hitch.
        </span>
        <span class="line">
To check this, run the following command:
        </span>
      </p>
      <pre class="block">
verify peano-axioms
      </pre>
      <p>
        <span class="line">
If all goes well then you should see the last ten lines of the output, something like this:
        </span>
      </p>
      <pre class="block">
INFO: peano-axioms/theorems.fls (91) - Verified the 'successor(n) = zero' supposition.
INFO: peano-axioms/theorems.fls (93) - Verified the 'zero = successor(n)' statement as an equality.
INFO: peano-axioms/theorems.fls (93) - Verified the 'zero = successor(n)' unqualified statement.
INFO: peano-axioms/theorems.fls (95) - Verified the 'zero:NonZeroNaturalNumber' qualified statement.
INFO: peano-axioms/theorems.fls (96) - Verified the '(successor(n) = zero) ⇒ zero:NonZeroNaturalNumber' qualified statement.
INFO: peano-axioms/theorems.fls (97) - Verified the '¬(zero:NonZeroNaturalNumber)' qualified statement.
INFO: peano-axioms/theorems.fls (99) - Verified the '¬(successor(n) = zero)' qualified statement.
INFO: peano-axioms/theorems.fls (82-99) - Verified the 'P8' theorem.
INFO: Verified the 'peano-axioms/theorems.fls' file.
INFO: Verified  'peano-axioms'.
      </pre>
      <p>
        <span class="line">
To see the last one hundred lines of output, run the following command:
        </span>
      </p>
      <pre class="block">
verify --tail=100 peano-axioms
      </pre>
      <p>
        <span class="line">
Lastly, if you would like to follow the output as the verifier does its work, run the following command:
        </span>
      </p>
      <pre class="block">
verify --follow peano-axioms
      </pre>
      <p>
        <span class="line">
There will be several hundred lines of output in this case because the verifier has to verify not just the <pre class="inline">peano-axioms</pre> project but all the projects it depends on.
        </span>
        <span class="line">
To bring this chapter to a close, therefore, remove all but the <pre class="inline">peano-axioms</pre> project and open its dependencies as packages rather than projects.
        </span>
        <span class="line">
Afterwards, when you verify the <pre class="inline">peano-axioms</pre> project the verifier will work much more quickly.
        </span>
      </p>
    </div>
    <div id="getting-to-grips-with-the-ide">
      <h1>
        <span class="line">
 Getting to grips with the IDE
        </span>
      </h1>
      <p>
        <span class="line">
As mentioned in the getting started chapter, Occam has its own IDE. 
        </span>
        <span class="line">
Actually Occam's CLI tools are not integrated with it as of yet and therefore it is really just a glorified collaborative text editor.
        </span>
        <span class="line">
Nonetheless it has it uses. 
        </span>
        <span class="line">
It supports Occam's own vernacular, for example, called Florence. 
        </span>
        <span class="line">
It will also unpack Occam's packages in its projects pane so that you can browse them as projects. 
        </span>
        <span class="line">
And it has useful indexing and navigation features.
        </span>
        <span class="line">
All told it is worth the effort of downloading and installing it and will only improve with time.
        </span>
        <span class="line">
Some effort has been made in order to make it as usable as possible and most of its functionaoity should therefore be discoverable.
        </span>
        <span class="line">
However, some functionality is subtle or hidden and so all of it is covered in what follows.
        </span>
      </p>
      <p>
        <span class="line">
To begin then, note that there are severral toolbars along the top as well as the several panes.
        </span>
        <span class="line">
All of the toolbars with input fields are sizable.
        </span>
        <span class="line">
Note that if you hover over the buttons then tooltips will appear.
        </span>
        <span class="line">
You can turn this feature off in the settings.
        </span>
        <span class="line">
Also note that most of the panes can be minimised in the obvious way.
        </span>
        <span class="line">
Moreover the vertical splitters, that is the draggable elements between the panes, can be double-clicked in order to minimise the left and right panes.
        </span>
      </p>
      <h2>
        <span class="line">
 Projects and packages
        </span>
      </h2>
      <p>
        <span class="line">
The first toolbar goes hand in hand with the projects pane.
        </span>
        <span class="line">
It has an input field for the projects directory that was mentioned earlier.
        </span>
        <span class="line">
Just to recap, you can change the projects directory at any time by typing a fully qualified path into this field and hitting return or clicking the refresh button.
        </span>
        <span class="line">
Note that all open documents will be closed when you do this.
        </span>
        <span class="line">
They will also all be closed if you hit the refresh button even without changing the projects directory.
        </span>
        <span class="line">
In effect the IDE does not differentiate between the two cases.
        </span>
      </p>
      <p>
        <span class="line">
Aside from the projects directory input field the projects toolbar has several buttons and a recycle bin for the project pane's files and directories.
        </span>
        <span class="line">
The button next to the recycle bin with the two arrows synchronises the active document, that is selects its corresponding file in the pane.
        </span>
        <span class="line">
The pencil button allows you to edit the name of the currently selected file or directory.
        </span>
        <span class="line">
The next botton allows you to show and hide packages.
        </span>
        <span class="line">
This is useful because packages do not live in their own directory but alongside projects.
        </span>
        <span class="line">
Hiding them temporarily is therefore often desirable.
        </span>
        <span class="line">
Lastly, the rightmost two buttons allow you to create files and directories, respectively.
        </span>
        <span class="line">
They will be created in the currently selected directory, if there is one, otherwise in the root projects directory.
        </span>
      </p>
      <p>
        <span class="line">
As for the projects pane itself, you can mostly drag filea and directories around freely.
        </span>
        <span class="line">
Bear in mind however that packages are immutable in the sense that their file and directory names cannot be changed.
        </span>
        <span class="line">
Also you cannot drag files in the projects directory, because only projbects and packages are loaded.
        </span>
        <span class="line">
Remember also that the topmost directories of packages are shown with a padlock.
        </span>
        <span class="line">
One other thing to bear in mind is that only what are known as recognised files are shown in the proejcts pane by default.
        </span>
        <span class="line">
Thus a file may seem to disappear if you drag it into a child directory, for example.
        </span>
        <span class="line">
Recognised files are those that go into packages, with other files being ignored.
        </span>
        <span class="line">
The one exception are <pre class="inline">\*.md</pre> files of which only <pre class="inline">README.md</pre> files in the topmost directories of projects make it into packages.
        </span>
        <span class="line">
Here is the list:
        </span>
      </p>
      <ul>
        <li>
          <span class="line">
<pre class="inline">\*.fls </pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">\*.md </pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">meta.json</pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">type.ptn</pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">symbol.ptn</pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">operator.ptn</pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">term.bnf</pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">statement.bnf</pre>
          </span>
        </li>
        <li>
          <span class="line">
<pre class="inline">metastatement.bnf</pre>
          </span>
        </li>
      </ul>
      <p>
        <span class="line">
All but <pre class="inline">\*.fls</pre> and <pre class="inline">\*.md</pre> files belong strictly in the topmost directories of projects and packages.
        </span>
        <span class="line">
As already mentioned, by default they will not show in the projects pane if placed elsewhere.
        </span>
        <span class="line">
There is no such restriction on <pre class="inline">.fls</pre> files and you are encouraged to cretae sub-directories for them.
        </span>
      </p>
      <h2>
        <span class="line">
 Sessions
        </span>
      </h2>
      <p>
        <span class="line">
The second toolbar goes with the sessions pane. 
        </span>
        <span class="line">
It has a rubbish bin and an input for session keys.
        </span>
        <span class="line">
There are also three buttons for creating, joining and leaving sessions, as well as a button to copy the session key to the clipboard.
        </span>
      </p>
      <p>
        <span class="line">
Clicking the button for creating a session when the session key input is left blank will create a seesion with a random key.
        </span>
        <span class="line">
It is recommended that you do this and then pass the session key to other session users by way of email or whatever.
        </span>
        <span class="line">
They can paste the session key into the session key input and then click the join session button in order to join the session.
        </span>
        <span class="line">
Anyone can leave a sesssion at any time, including the creator.
        </span>
        <span class="line">
In fact the session will persist on the server for half a minute or so even when everyone has left during which time it can be re-joined.
        </span>
      </p>
      <p>
        <span class="line">
Once a session is created you can drag files and folders into it from the projects pane.
        </span>
        <span class="line">
These can then be removed from the session by dragging them into the rubbish bin to the left of the session key input.
        </span>
        <span class="line">
Anyone can add and remove files to and from a session, by the way, the session creator has no special privileges.
        </span>
        <span class="line">
Also bear in mind that if someone drags a file into a session that already exists in one of your projects then this file will be altered concurrently regardless of whether you have it open in the editor or not.
        </span>
        <span class="line">
Finally, bear in mind that adding package files to sessions can cause problems, because if another session user has the file as a project file then they will be able to alter it.
        </span>
        <span class="line">
Consequently your package file will be altered concurrently and this is unlikely to be the desired behaviour.
        </span>
      </p>
      <h2>
        <span class="line">
 The console and settings
        </span>
      </h2>
      <p>
        <span class="line">
At present the console is not interactive and only logs 'error', 'warning', 'info', 'debug' and 'trace' level messages.
        </span>
        <span class="line">
The log level can be adjusted in the settings pane on the right.
        </span>
        <span class="line">
The recommended level is 'info', which will ensure that you see all pertinent messages.
        </span>
        <span class="line">
All messages are sent to the console but may not be shown if the log level has been set to preclude them.
        </span>
        <span class="line">
So if something appears to have gone wrong then the relevant debug and trace messages will still be avaialble if the log level is subsequently set appropriately.
        </span>
        <span class="line">
Note that the IDE has been designed so that if you keep the log level at 'info' then during normal operation you will not see any messages at all.
        </span>
      </p>
      <p>
        <span class="line">
Of the other settings, hopefully most will be self explanatory.
        </span>
        <span class="line">
Of the ones that perhaps need an explanation, showing only recognised files has already been touched upon in the projects and packages section above.
        </span>
        <span class="line">
If you choose not to copy Unicode characters to the clipboard then they will pasted directly into the active document, otherwise being discarded.
        </span>
        <span class="line">
If you enable the loading of hidden files and directories then be aware that Git creates a hidden directory in cloned projects and that it can potentially contain thousands of entries.
        </span>
        <span class="line">
In fact this setting was added precisely to stop the hidden Git directory from being loaded.
        </span>
        <span class="line">
Disable it at your peril, therefore.
        </span>
        <span class="line">
Lastly, going straight to singular labels and references means that if you, click on a label, say, then if there is only one corresponding reference then you will be taken straight to it rather than a link to it being givem in the console.
        </span>
        <span class="line">
And vice versa if you click on a reference.
        </span>
      </p>
      <h2>
        <span class="line">
 Editing
        </span>
      </h2>
      <p>
        <span class="line">
Little explanation of the editor's functionality is needed and it will hopefully feel familiar to anyone who has used such tools before.
        </span>
        <span class="line">
There are two toolbars that go along with it, namely the find and Unicode toolbars.
        </span>
        <span class="line">
These are tied up with the keyboard shortcuts, which is perhaps the only thing that requires further explanation aside from the menu in the bottom-right corner of the editor itself.
        </span>
        <span class="line">
This remains hidden until you mouse over it.
        </span>
        <span class="line">
It has buttons to increase and decrease the editor's font size as well as buttons to toggle the presentation mode.
        </span>
      </p>
      <p>
        <span class="line">
Starting with the fold functionality, folds can of course be expanded or collapsed by clicking on their buttons with the mouse.
        </span>
        <span class="line">
The corresponding keyboard shortcuts are the command or control key together with the plus and minus keys which will expand or collapse any folds enclosing the selections, respectively.
        </span>
        <span class="line">
Holding down the shift key at the same time will expand or collapse all the folds.
        </span>
      </p>
      <p>
        <span class="line">
There are two kinds of find functionality, namely what might be calling finding and grouping.
        </span>
        <span class="line">
For finding, both in the file being currently edited and in all the files in the loaded projects and packages, the keyboard shortcut is the command or control key together with the 'F' key.
        </span>
        <span class="line">
This moves the input focus to the content input field of the find toolbar from where you can type in the content you wish to find.
        </span>
        <span class="line">
Clicking the first of buttons to the right of this field will find the content in the file being edited, or you can hit the enter key.
        </span>
        <span class="line">
In either case the focus will return to the editor with the content to be found under the sole selection.
        </span>
        <span class="line">
On the other hand if you click the second button then a list of links of occurences of the content to be found in all of the loaded projects and packages will be given in the console.
        </span>
        <span class="line">
Bear in mind that these link are shown as 'info' level messages and therefore if you have the log level set at a higher level then you will miss them.
        </span>
      </p>
      <p>
        <span class="line">
The second kind of find functionality is grouping and this happens in the editor without its focus being taken away.
        </span>
        <span class="line">
The requisite keyboard shortcut is the command or control key together with the 'G' key.
        </span>
        <span class="line">
If nothing is selected, that is only carets are showing, then the token underneath the first caret will be selected.
        </span>
        <span class="line">
If there is already a selection then its next occurrence of the selected content will be selected.
        </span>
        <span class="line">
This process can be repeated until all occurrences have been found, or hold down the shift key to group all occurences at once.
        </span>
      </p>
      <p>
        <span class="line">
The editor fully supports Unicode but of course no keyboard can.
        </span>
        <span class="line">
In order to get around this the Unicode toolbar has been provided.
        </span>
        <span class="line">
The keyboard shortcut is the command or control key together with the 'U' key, which moves the input focus to the Unicode character input field.
        </span>
        <span class="line">
Typing into this field will reveal a drop down list of filtered Unicode characters, one of which will always be selected.
        </span>
        <span class="line">
Hitting the enter key will paste this character into and return the focus to the edited document.
        </span>
        <span class="line">
Or you can click on any character in the dropdown list to give the same result.
        </span>
      </p>
      <p>
        <span class="line">
Lastly, a word or two about undo and redo functionality.
        </span>
        <span class="line">
The keyboard shortcut to undo the last group of operations is the usual command or control key together with the 'Z' key.
        </span>
        <span class="line">
For redoing, hold the shift key down.
        </span>
        <span class="line">
Unlike other text editors if you partically traverse the redo buffer and then make a fresh operation then the partial remains of the redo buffer are not obliterated.
        </span>
        <span class="line">
Instead they are transformed using the same operational trnasformations that are employed in sessions.
        </span>
        <span class="line">
Thus the redo buffer will appear to degrade over time rather than immediately disappearing altogether and this can be disconcerting.
        </span>
        <span class="line">
If this explanation does not entirely make sense or if you encounter this mechanism unexpectedly then the best advice is probably to pick a toy example file and familiarise yourseif with the mechasnim by way a few operations either way.
        </span>
        <span class="line">
Finally, on the subject sessions, bear in mind that concurrent user's operations are not added to your own undo and redo buffers because they cause a blow up in their size.
        </span>
      </p>
      <h2>
        <span class="line">
 Exporting custom grammars
        </span>
      </h2>
      <p>
        <span class="line">
The very last toolbar to mention is the grammars toolbar, which only has one button to export the custom grammars.
        </span>
        <span class="line">
If a project or package is selected at the time then clicking this button will export the corresponding custom grammar together with custom grammars on which it depends.
        </span>
        <span class="line">
Otherwise the custom grammars for all of the loaded projects and packages will be exported.
        </span>
      </p>
    </div>
    <div id="understanding-grammars">
      <h1>
        <span class="line">
 Understanding Grammars
        </span>
      </h1>
      <p>
        <span class="line">
Occam's grammars functionality is one of its strongest suits but what exactly is a grammar, at least in Occam's parlance?
        </span>
        <span class="line">
A grammar can loosely be described as that which is needed to describe and work with a language.
        </span>
        <span class="line">
More specifically, it can be thought of as comprising three parts:
        </span>
      </p>
      <ol start="1">
        <li>
          <span class="line">
 A collection of symbols or characters that are the smallest elements of the language. These symbols or characters are usually viscerally synonymous with the glyphs that represent them. In our case a sequence of such characters is what comprises the content of a document or file.
          </span>
        </li>
      </ol>
      <ol start="2">
        <li>
          <span class="line">
 A set of rules, usually based on regular expressions,<a class="link" href="#regular-expressions">1</a> to collect these characters into larger elements, called tokens or lexemes. We tend to envisage a sequence of characters as continuous rather than discrete, however, and therefore tend to think of these rules as chopping up the content rather than gathering it. This process is called lexing or tokenising and we stick with the latter.
          </span>
        </li>
      </ol>
      <ol start="3">
        <li>
          <span class="line">
 Another set of rules, written in BNF,<a class="link" href="#bnf">2</a> that are responsible for organising these tokens into larger elements. In the case of a natural language these would be phrases, sentences, paragraphs and so on. This process is called parsing the tokens or, by extension, the content The resulting structure is usually called an abstract syntax tree or AST for short. We call it a parse tree, however.
          </span>
        </li>
      </ol>
      <h2>
        <span class="line">
 Language flexibility and extensibility
        </span>
      </h2>
      <p>
        <span class="line">
Consider the following variable declaration written in Occam's default language, called Florence:
        </span>
      </p>
      <pre class="block">
Variable n:ℕ
      </pre>
      <p>
        <span class="line">
Here we are declaring a variable named <pre class="inline">n</pre> to be of natrual number type, represented by the double-struck <pre class="inline">\ℕ</pre> character.
        </span>
        <span class="line">
Now look at the parse tree. This is what what the verifier would see, so to speak:
        </span>
      </p>
      <pre class="block">
                                      variableDeclaration [0]                             
                                                 |                                        
               ---------------------------------------------------------------------
               |                      |               |              |             |      
"Variable"[primary-keyword] [0] variable [0]  ":"[special] [0]   type [0]    <END_OF_LINE>
                                      |                              |                    
                                "x"[name] [0]                  "\ℕ"[type] [0]              
      </pre>
      <p>
        <span class="line">
It should be clear from this parse tree that we have a variable declaration to hand, with the aforementioned <pre class="inline">n</pre> varaible and <pre class="inline">\ℕ</pre> type.
        </span>
        <span class="line">
It is not too hard to imagine that the verifier can extract this information from the parse tree by traversing it somehow, and this is indeed the case.
        </span>
      </p>
      <p>
        <span class="line">
Now consider the same variable declaration but written in a controlled natural language, or CNL for short.
        </span>
        <span class="line">
Occam does not natively support this language as yet but will do so in the future.
        </span>
        <span class="line">
For the moment it can be created using the grammars sandbox that is the subject of the next chapter:
        </span>
      </p>
      <pre class="block">
Let x be a variable of type ℕ.
      </pre>
      <p>
        <span class="line">
Here is the resultant parse tree:
        </span>
      </p>
      <pre class="block">
                                                            variableDeclaration [0]                                                              
                                                                       |                                                                         
       ---------------------------------------------------------------------------------------------------------------------------------
       |              |              |             |                 |                 |               |              |                |         
"Let"[name] [0] variable [0]  "be"[name] [0] "a"[name] [0] "variable"[name] [0] "of"[name] [0] "type"[name] [0]   type [0]    "."[unassigned] [0]
                      |                                                                                               |                          
                "x"[name] [0]                                                                                   "\ℕ"[type] [0]                    
      </pre>
      <p>
        <span class="line">
Note that exactly the same information can be extracted from this parse tree as from the previous one, even though the language has changed.
        </span>
        <span class="line">
The verifier would be able to ascertain that this is indeed a variable declaration from the topmost <pre class="inline">variableDeclaration</pre> node, for example.
        </span>
        <span class="line">
Similarly it could also ascertain that the variable is called <pre class="inline">n</pre> and that its type is <pre class="inline">\ℕ</pre>, just as before.
        </span>
      </p>
      <p>
        <span class="line">
In essence the parse trees would appear to be identical to the verifier, in fact, since it ignores elements that were not pertinent.
        </span>
        <span class="line">
The <pre class="inline">Variable</pre> keyword in the Florence parse tree would be ignored, for example, or the <pre class="inline">Let</pre>, <pre class="inline">be</pre> and <pre class="inline">a</pre> keywordds in the CNL parse tree.
        </span>
      </p>
      <p>
        <span class="line">
In summary, for all intents and purposes the Flroence and CNL languages will appear to be identical to the verifier and not just for varaible declarations but every pertinent language element.
        </span>
        <span class="line">
Furthermore, it should be clear that the natural language parts of CNL can be akin to any natural language, it does not have to be English.
        </span>
        <span class="line">
This flexibility with languages is an important feature of Occam.
        </span>
      </p>
      <p>
        <span class="line">
Occam also allows languages to be extended.
        </span>
        <span class="line">
Consider the following inference rule.
        </span>
        <span class="line">
Quite what an inference rule is or what this one is useful for are not important at this stage, by the way:
        </span>
      </p>
      <pre class="block">
Rule (ModusPonens)
  Premises
    A ⇒ B
    A
  Conclusion
    B
      </pre>
      <p>
        <span class="line">
Now consider the parse tree for the first of the premises:
        </span>
      </p>
      <pre class="block">
                         unqualifiedMetastatement [0]        
                                       |                     
                       --------------------------------      
                       |                              |      
                 nonsense [0]                   <END_OF_LINE>
                       |                                     
      -----------------------------------                    
      |                |                |                    
"A"[name] [0] "⇒"[unassigned] [0] "B"[name] [0]              
      </pre>
      <p>
        <span class="line">
Note that it does indeed parse, but that it is being parsed as nonsense.
        </span>
        <span class="line">
This is the fallback if the metastatement cannot be parsed in a more meaningful way.
        </span>
      </p>
      <p>
        <span class="line">
To make sense of this metastatement, we first augment the grammar with a regular exprssion pattern that picks out the <pre class="inline">\⇒</pre> implication character as an operator token.
        </span>
        <span class="line">
The following parse tree shows that the metastatement still parses as nonsense but that this character is at least being recognised as an operator:
        </span>
      </p>
      <pre class="block">
                       unqualifiedMetastatement [0]        
                                     |                     
                      -------------------------------      
                      |                             |      
                nonsense [0]                  <END_OF_LINE>
                      |                                    
      ---------------------------------                    
      |               |               |                    
"A"[name] [0] "⇒"[operator] [0] "B"[name] [0]              
      </pre>
      <p>
        <span class="line">
Next, we augment the <pre class="inline">metastatement</pre> rule in the BNF to include metastatements of the requisite form:
        </span>
      </p>
      <pre class="block">
metastatement ::= metavariable "\⇒" metavariable ;
      </pre>
      <p>
        <span class="line">
As a result of these changes we get a <pre class="inline">metastatement</pre> node instead of a <pre class="inline">nonsense</pre> one:
        </span>
      </p>
      <pre class="block">
                            unqualifiedMetastatement [0]         
                                          |                      
                          ---------------------------------      
                          |                               |      
                  metastatement [0]                 <END_OF_LINE>
                          |                                      
        ------------------------------------                     
        |                |                 |                     
metavariable [0] "⇒"[operator] [0] metavariable [0]              
        |                                  |                     
  "A"[name] [0]                      "B"[name] [0]               
      </pre>
      <p>
        <span class="line">
What this means in practice is not just a more sensical parse tree.
        </span>
        <span class="line">
With this rule now working its premises and conclusion can be matched to other metastatements and statements in derivations by the verifier.
        </span>
        <span class="line">
This means that whereas before augmenting the grammar the verifier would have fallen over when encountering this rule, now it would be able to continue.
        </span>
      </p>
      <p>
        <span class="line">
Indeed it could be said that about half the job of verification is getting content to parse by way of extening Occam's in-built grammars.
        </span>
        <span class="line">
As mentioned earlier, there is a grammars sandbox to help you with this work.
        </span>
        <span class="line">
So like Occam's flexibility with languages, extensibility is an important feature.
        </span>
      </p>
      <h2>
        <span class="line">
 Unicode
        </span>
      </h2>
      <p>
        <span class="line">
The first of the points at the beginning of this chapter suggested that any grammar needs a collection of characters or symbols.
        </span>
        <span class="line">
In Occam's case this is Unicode, a near ubiliquitous standard that encompasses close to 150,000 characters to date and has the potential to support over a million.
        </span>
        <span class="line">
These characters are organised across various planes, namely the basic multilingual plane, or BNP for short, together with sixteen so-called astral planes.
        </span>
        <span class="line">
For example, the aforementioned double-struck <pre class="inline">\ℕ</pre> character, being regularly used in mathematical texts, can be found in the basic multilingual plane.
        </span>
        <span class="line">
On the other hand the `𝔸` character, being far less common, is relegated to an astral plane.
        </span>
        <span class="line">
In practice the position of a Unicode character, called its code point, is immaterial.
        </span>
        <span class="line">
As mentioned in the previous chapter, the Occam IDE has a Unicode picker to enable you to pick from a large selection of Unicode characters without knowing their code points.
        </span>
        <span class="line">
Mention should also go the JuliaMono typeface,<a class="link" href="#juliamono">3</a> which is used in the editor and which has support for thousands of Unicode characters.
        </span>
      </p>
      <h2>
        <span class="line">
 Tokenising content with lexers
        </span>
      </h2>
      <p>
        <span class="line">
There are several lexers to be found in the Occam grammars package.<a class="link" href="#occam-grammars">4</a>
        </span>
        <span class="line">
In fact these are all the same lexer but configured slightly differently.
        </span>
      </p>
      <p>
        <span class="line">
In essence Occam's lexer is a state machine having two states, namely 'in comment' and 'not in comment'.
        </span>
        <span class="line">
Depending on these states it uses a different sequence of both in-built and user defined rules to tokenise content.
        </span>
        <span class="line">
The order in which the rules are executed matters.
        </span>
        <span class="line">
Comments must be picked out before string literals, for example.
        </span>
      </p>
      <p>
        <span class="line">
For each of the grammars a <pre class="inline">CommonLexer</pre> class is extended with divers static properties which essentially define its in-built rules.
        </span>
        <span class="line">
For example, a particular lexer might pick out C-style comments as opposed to Perl-style ones, or it might not pick out comments at all.
        </span>
        <span class="line">
Simiarly it might pick out string literals or, again, it might not.
        </span>
      </p>
      <p>
        <span class="line">
As well as picking out verious types of token, lexers distinguish between two kinds of token, namely significant and non-significant tokens.
        </span>
        <span class="line">
Significant tokens will be picked up by the parser further down the line whereas non-significant tokens are largely ignored.
        </span>
        <span class="line">
There are subtleties in this, however, which we will come to later on.
        </span>
        <span class="line">
One worth mentioning now however is that end of line tokens can be either significant or non-significant depending on the particular lexer's configuration.
        </span>
      </p>
      <p>
        <span class="line">
Unlike a lexer's in-built rules, its user defined rules are defined by so-called lexical entries in JSON form.
        </span>
        <span class="line">
These are essentially mappings of token types to the regular expression patterns that match them.
        </span>
        <span class="line">
For example, here are the entries for the plain text lexer:
        </span>
      </p>
      <pre class="block">
[
  {
    "alpha-numeric": "^[a-zA-Z0-9]+"
  },
  {
    "punctuation": "^[@,\\.\"'`]+"
  },
  {
    "unassigned": "^[^\\s]+"
  }
]
      </pre>
      <p>
        <span class="line">
User defined rules are tried should the lexer's in-built rules fail to match the content and they are tried in order from top to bottom.
        </span>
        <span class="line">
Note that all of hte regular expression patterns start with the <pre class="inline">^</pre> caret character which matches the start of the content.
        </span>
        <span class="line">
Thus it is reasonable to envisage the lexer as consuming the content from left to right.
        </span>
      </p>
      <p>
        <span class="line">
One other thing to note is that the last user-defined rule will match anything but whitespace.
        </span>
        <span class="line">
Given that a prior in-built rule will have already matched any whitespace this guarantees that the plain text lexer will cope with any input.
        </span>
        <span class="line">
We call this robustness and come back to this important property of both lexers and pareers in a later section.
        </span>
      </p>
      <h2>
        <span class="line">
 Parsing tokens with parsers
        </span>
      </h2>
      <p>
        <span class="line">
Like the lexers, there are several parsers to be found in the Occam grammars package.<a class="link" href="#occam-grammars">5</a>
        </span>
        <span class="line">
And again like the lexers, these are all in fact the same common parser but configured differently in each case. 
        </span>
        <span class="line">
Specifically, a <pre class="inline">CommonParser</pre> class is extended for each grammar although, unlike the lexers, there are no other specific properties or in-built rules.
        </span>
        <span class="line">
The only thing that differentiates each parser is its associated BNF.
        </span>
      </p>
      <p>
        <span class="line">
It is worth a moment to look at BNF in more detail.
        </span>
        <span class="line">
Imagine you want to parse an arithmetic expression.
        </span>
        <span class="line">
You would require something like the following rules at least...
        </span>
      </p>
      <p>
        <span class="line">
An arithmetic expression can be:
        </span>
      </p>
      <ol start="1">
        <li>
          <span class="line">
 Another arithmetic expression enclosed in brackets,
          </span>
        </li>
        <li>
          <span class="line">
 two other arithmetic expressions separated by a binary operator,
          </span>
        </li>
        <li>
          <span class="line">
 a number.
          </span>
        </li>
      </ol>
      <p>
        <span class="line">
Furthermore we would have to define two other rules:
        </span>
      </p>
      <ol start="4">
        <li>
          <span class="line">
 An operator is an addition, subtraction, division or multiplication character.
          </span>
        </li>
        <li>
          <span class="line">
 A number is a series of one or more decimal digits.
          </span>
        </li>
      </ol>
      <p>
        <span class="line">
Such natural language specifications are both cumbersome and ambiguous, however.
        </span>
        <span class="line">
All BNF does is make all of this precise:
        </span>
      </p>
      <pre class="block">
expression ::= "(" expression ")"

             | expression operator expression

             | number

             ;

  operator ::= "+" | "-" | "÷" | "×" ;

    number ::= /d+/ ;
      </pre>
      <p>
        <span class="line">
It is not going too far to claim that not only are the above rules clearer than their natural language counterparts but that they could have been given with no prior explanation at all.
        </span>
        <span class="line">
Such is BNF's great utility, if employed with common sense.
        </span>
      </p>
      <p>
        <span class="line">
We end this section with a brief description of how Occam's parser works.
        </span>
        <span class="line">
There is no need for a deep understanding but having at least a passing familiarity with the process may avoid frustration later on.
        </span>
        <span class="line">
So, Occam's parser is what is known as a top-down parser.
        </span>
        <span class="line">
Its goal is to evaluate the start rule, which is usually the first rule, during the process of which all of the tokens should be consumed.
        </span>
        <span class="line">
It evaluates a rule by evaluating each of its definitions in turn.
        </span>
        <span class="line">
If one of a these definitions evaluates then rule evaluates and we are done.
        </span>
        <span class="line">
In order to evaludate a definition all of its parts must evaluate.
        </span>
        <span class="line">
Parts are generally either non-terminal, that is they simply point to a rule; or terminal, in which case they match a token.
        </span>
        <span class="line">
There is a third category of parts called complex parts which are perhaps best described as in-ine rules.
        </span>
      </p>
      <p>
        <span class="line">
It is worth a moment to imagine a top down parser, configured with the BNF above, parsing an arithmetic expression such as <pre class="inline">(1+2)÷3</pre>.
        </span>
        <span class="line">
It should become clear why the second definition of the <pre class="inline">expression</pre> rule is going to create problems.
        </span>
        <span class="line">
When the parser encounters this definition it will try to evaluate the <pre class="inline">expression</pre> rule again and if the first definition cannot be evaluated then the parser will loop indefinitely.
        </span>
        <span class="line">
This problem can be alleviated by rewriting the BNF under the hood but it is reasonable to ask why another parser achtiteture cannot be adopted, one that is not susceptible to left recursion.
        </span>
        <span class="line">
The answer is that all parser architectures are susceptible to one form of recursion or another and top down parsers are generally by far the simplest and fastest.
        </span>
        <span class="line">
We come back to this particular form of recursion, called left recursion, later on.
        </span>
      </p>
      <h2>
        <span class="line">
 The Florence grammar
        </span>
      </h2>
      <p>
        <span class="line">
Some familiarity with the Florence grammar is helpful and so we look at its constituent parts now. 
        </span>
        <span class="line">
Here is the definition of the <pre class="inline">FlorenceLexer</pre> class:
        </span>
      </p>
      <pre class="block">
class FlorenceLexer extends CommonLexer {
  ...
  static EndOfLineToken = EndOfLineSignificantToken;

  static WhitespaceToken = WhitespaceToken;

  static RegularExpressionToken = null;

  static EndOfLineCommentToken = EndOfLineCommentSignificantToken;

  static SingleLineCommentToken = PythonStyleSingleLineCommentToken;

  static EndOfMultiLineCommentToken = PythonStyleEndOfMultiLineCommentToken; 

  static StartOfMultiLineCommentToken = PythonStyleStartOfMultiLineCommentToken; 

  static MiddleOfMultiLineCommentToken = PythonStyleMiddleOfMultiLineCommentToken; 

  static SinglyQuotedStringLiteralToken = null;

  static DoublyQuotedStringLiteralToken = DoublyQuotedStringLiteralToken;
}
      </pre>
      <p>
        <span class="line">
Note that end of line tokens are significant, like YAML or Python but unlike JSON or Java. 
        </span>
        <span class="line">
Note also that both single and multiple line Python style comments are supported. 
        </span>
        <span class="line">
And lastly note that doubly quoted string literals are preferred to singly quoted ones and that regular expression literals are not supported.
        </span>
        <span class="line">
These properties define the in-built rules and in addition to these we have the following lexical entries for the user defined rules.
        </span>
        <span class="line">
The regular expression pattern for the <pre class="inline">primary-keyword</pre> entry has been abridged, by the way:
        </span>
      </p>
      <pre class="block">
[
  {
    "special": "^(?:,|::|:|=|\\(|\\)|\\[|\\]|\\.\\.\\.)"
  },
  {
    "primary-keyword": "^(?:Rule|Axiom|Theorem|Lemma|Conjecture|Metalemma|Metatheorem|Premises|Premise|Conclusion|Proof...)\\b"
  },
  {
    "secondary-keyword": "^(?:from|by)\\b"
  },
  {
    "meta-type": "^(?:Statement|Context)\\b"
  },
  {
    "name": "^[A-Za-zΑ-Ωα-ω][A-Za-zΑ-Ωα-ω_0-9]*"
  },
  {
    "unassigned": "^[^\\s]+"
  }
]
      </pre>
      <p>
        <span class="line">
Note that the regular expression pattern for the last <pre class="inline">unassigned</pre> token type will match anything but whitespace.
        </span>
        <span class="line">
In fact again we make the point, as we did with the plain text lexer, that since a prior in-built rule will have already matched any whitespace this guarantees that the Florence lexer will cope with any input.
        </span>
      </p>
      <p>
        <span class="line">
Here is the abridged top-level part of the BNF for the parser:
        </span>
      </p>
      <pre class="block">
document                             ::=   ( topLevelDeclaration | verticalSpace | error )+ ;

topLevelDeclaration                  ::=   typeDeclaration 
                                           
                                       |   variableDeclaration 

                                       ...                                           
                                           
                                       |   rule 

                                       |   axiom 

                                       |   lemma 

                                       |   theorem 

                                       |   conjecture 

                                       |   metalemma 

                                       |   metatheorem 

                                       ;

verticalSpace                        ::=   <END_OF_LINE>+ ;

error                                ::=   . ;
      </pre>
      <p>
        <span class="line">
There are some points to note here, too.
        </span>
        <span class="line">
Firstly, the <pre class="inline">verticalSpace</pre> rule matches one or more end of line tokens.
        </span>
        <span class="line">
Recall that the Florence lexer is configured to treat such tokens as significant, hence they can be referenced here.
        </span>
        <span class="line">
Also, the <pre class="inline">document</pre> rule's definition has a complex part which stipulates one or more of a choice of three parts.
        </span>
        <span class="line">
These will be evaluated in sequence and therefore the <pre class="inline">error</pre> rule provides the required fallback functionality.
        </span>
        <span class="line">
Its single definition has only one wildcard part <pre class="inline">.</pre> that will match any significant token, as its name suggests.
        </span>
        <span class="line">
Thus Occam's parsers can be said to be robust, in a similar vein to its lexers, in the sense that they will cope with any input.
        </span>
        <span class="line">
Robustness is picked up again in the later section on ambiguity.
        </span>
      </p>
      <p>
        <span class="line">
Here is part of the mid-level BNF:
        </span>
      </p>
      <pre class="block">
unqualifiedMetastatement!            ::=   metastatement... <END_OF_LINE> 

                                       |   nonsense... <END_OF_LINE> 
                                       
                                       ;

qualifiedMetastatement!              ::=   metastatement... qualification <END_OF_LINE> 

                                       |   nonsense... qualification <END_OF_LINE> 
                                        
                                       ;

...                                       

qualification                        ::=   ( "by" | "from" ) reference ;

nonsense                             ::=   ( [type] | [symbol] | [operator] | [special] | [secondary-keyword] | [meta-type] | [name] | [unassigned] )+ ;
      </pre>
      <p>
        <span class="line">
Since ambiguity is being treated later we will pass over the fact that each of the first two rules have two definitions and the use of the exclamation mark after these rules' names.
        </span>
        <span class="line">
Instead we focus on the ellipsis <pre class="inline">...</pre> modifier on each of the rule name parts.
        </span>
        <span class="line">
This switches the parser into what is called a look-ahead state, where it takes note of the part that follows the look-ahead part when evaluating the look-ahead part itself.
        </span>
        <span class="line">
This is useful because the <pre class="inline">nonsense</pre> rule if left to its own devices would parse a qualification, since it parses one or more tokens of pretty much any type.
        </span>
        <span class="line">
If it can be made to look ahead, however, it will stop before the qualification thus allowing the parser to continue to evaluate the <pre class="inline">qualification</pre> part of the definition.
        </span>
      </p>
      <p>
        <span class="line">
It is not unreasonable to ask why this look-ahead state is not the default state of the parser, given its obvious utility.
        </span>
        <span class="line">
Ths answer is that it slows the parser down considerably.
        </span>
        <span class="line">
On one hand in its normal state the parser will parse a sequence of tokens in time roughly linearly proportional to the sequence's length.
        </span>
        <span class="line">
On the other hand in its look-ahead state, although no detailed profiling has ever been done, it seems most likely that the time is likely to be if not expoenentially then at least polynomially proportional.
        </span>
        <span class="line">
Thus although a look-ahead state was a necessity when designing the parser, it is used throughout all of Occam's grammars with considerable caution.
        </span>
      </p>
      <p>
        <span class="line">
We bring this section to a close with mention of custom grammars.
        </span>
        <span class="line">
These are the subject of the next chapter but because they augment the Florence grammar, it makes sense to at least mention the default custom grammar here.
        </span>
        <span class="line">
This grammar completes the Florence grammar with additional regular expression patterns for the lexer and additional rules for the parser.
        </span>
        <span class="line">
Here are the regular expression patterns, for the <pre class="inline">type</pre> and <pre class="inline">symbol</pre> and <pre class="inline">operator</pre> token types, with the second of these being empty:
        </span>
      </p>
      <pre class="block">
typePattern = "Object";

symbolPattern = "";

operatorPattern = "⊧|is|for|omits|contains|undefined";
      </pre>
      <p>
        <span class="line">
Note that the <pre class="inline">operatorPattern</pre> regular expression pattern would have been augmented with the implication character earlier.
        </span>
      </p>
      <p>
        <span class="line">
And here are the abridged BNF rules:
        </span>
      </p>
      <pre class="block">
term!                                ::=   variable ;

statement!                           ::=   "(" metaArgument ")" 
                                                  
                                       |   equality

                                       |   typeAssertion 
                                                  
                                       |   undefinedAssertion

                                       ;
                                       
equality                             ::=   argument "=" argument ;

typeAssertion                        ::=   term ":" type ;

undefinedAssertion                   ::=   variable "is" "undefined" ;

metastatement!                       ::=   "(" metastatement ")" 
           
                                       ...
                                        
                                       ;

...
      </pre>
      <p>
        <span class="line">
These are a bit more convoluted but note the presence of the <pre class="inline">metastatement</pre> rule which again would have been augmented earlier.
        </span>
      </p>
      <h2>
        <span class="line">
 Ambiguity
        </span>
      </h2>
      <p>
        <span class="line">
Recall that all of both Occam's lexers and parsers are configured to be robust in the sense that they will cope with any input.
        </span>
        <span class="line">
In the case of the lexers, robustness is guaranteed by an in-built rule that matches whitespace together with a last user defined <pre class="inline">unassigned</pre> rule that matches anything but whitespace.
        </span>
        <span class="line">
In the case of the parsers, robusteness is guaranteed by an <pre class="inline">error</pre> rule that is always given as the last choice in the singular definitions of start rules.
        </span>
      </p>
      <p>
        <span class="line">
Thus robustness is guaranteed by ambiguity.
        </span>
        <span class="line">
Under normal circumstances there should be no unassigned tokens or error nodes, but nonetheless all of the content can be tokenised as whiteapce and unassigned tokens and parsed as error nodes.
        </span>
        <span class="line">
So there are always at least two sequences of tokens and two parse trees for any input.
        </span>
      </p>
      <p>
        <span class="line">
Ambiguity is considered unacceptable from a theoretical standpoint but what would happen were it not built in to all of Occam's grammars?
        </span>
        <span class="line">
If we wanted to guarantee robustness for the lexers then we would have to hard code an in-built rule to run after the user defined rules expressly for the purposes of catching any content not matched beforehand.
        </span>
        <span class="line">
But this is precisely what the <pre class="inline">unassinged</pre> rule does.
        </span>
        <span class="line">
Simimlarly, if we wanted to guarantee robustness for the parsers then we would have to engineer them in such a way as to default to an error node somehow should no other nodes be possible.
        </span>
        <span class="line">
This approach was attempted early on in development, in fact, but it was abandoned as it compllicated the parser enormously.
        </span>
        <span class="line">
In the end any attempt to solve the problem of robustness programmatically simply simulates these <pre class="inline">unassigned</pre> and <pre class="inline">error</pre> rules, often at considerable programmatic cost.
        </span>
        <span class="line">
Thus the kind of ambiguity brought about by unassigned tokens and error nodes is unavoidable in lexers and parsers that have to work in practice.
        </span>
      </p>
      <p>
        <span class="line">
The other use for ambiguity has already been touched upon, namely the <pre class="inline">nonsense</pre> rules.
        </span>
        <span class="line">
Because these rules are referenced in definitions that come after the ones that reference the <pre class="inline">statement</pre> and <pre class="inline">metstatement</pre> rules, the latter should always be evaluated first.
        </span>
        <span class="line">
The need for nonsense nodes is not as pressing as error nodes and they do not contribute to robustness overall.
        </span>
        <span class="line">
Their utility lies in permitting high level nodes such as theorem nodes to remain intact whilst a user finishes typing a statement in the IDE, say.
        </span>
        <span class="line">
Furtherfmore, nonsense nodes allow documents to be parsed with only the default custom grammar which makes indexing in the IDE much faster.
        </span>
      </p>
      <p>
        <span class="line">
The exclamation mark <pre class="inline">!</pre> modifier on the <pre class="inline">statement</pre> and <pre class="inline">metastatement</pre> rules, amongst others, deserves mention at this point.
        </span>
        <span class="line">
These modifiers flag rules as potentially ambiguous but they are not used consistently throughout.
        </span>
        <span class="line">
The topmost <pre class="inline">document</pre> rule is deliberately ambiguous, for example, but it is not flagged as such.
        </span>
        <span class="line">
The reason is that in practice this modifier is used to tell the incremental algorithm not to recurse into the rule during its parsing stage since this can cause problems.
        </span>
        <span class="line">
An exception has to be made for the topmost rule, however, since instructing the incremental algorithm not to recurse into it would defeat its purpose entirely.
        </span>
      </p>
      <p>
        <span class="line">
Finally on the subject of ambiguity, the astute reader may well also ask whether the order of definitions can be relied upon givevn that the BNF may be rewritten in order to eliminate left recursion.
        </span>
        <span class="line">
The answer is that it is assumed that the rules where ambiguity happens are not left recursive.
        </span>
        <span class="line">
This is indeed an assumption, but in practice it holds.
        </span>
      </p>
      <h2>
        <span class="line">
 Precedence
        </span>
      </h2>
      <p>
        <span class="line">
Another of Occam's grammar features is precedence.
        </span>
        <span class="line">
Consider the following arithmetic expression:
        </span>
      </p>
      <pre class="block">
1+2/3-4
      </pre>
      <p>
        <span class="line">
We would like this to parse whilst respecting the precedence of the operators.
        </span>
        <span class="line">
The following BNF will achieve this in the standard way:
        </span>
      </p>
      <pre class="block">
            expression ::= additionalTerm... "." ;


        additionalTerm ::= additionalTerm additionalOperator multiplicativeTerm

                         | multiplicativeTerm

                         ;

    multiplicativeTerm ::= multiplicativeTerm multiplicativeOperator number

                         | number

                         ;


    additionalOperator ::= "+" | "-" ;

multiplicativeOperator ::= "*" | "/" ;


                number ::= /d+/ ;
      </pre>
      <p>
        <span class="line">
To summarise the approach quickly, precedence is enforced by way of splitting the operators into two separate rules.
        </span>
        <span class="line">
The exact details are not important, however we give the parse tree in passing:
        </span>
      </p>
      <pre class="block">
                                                                                                                                expression [0]                                       
                                                                                                                                       |                                             
                                                                                                  --------------------------------------------------------------------------         
                                                                                                  |                                                                        |         
                                                                                         additionalTerm [0]                                                       "."[unassigned] [0]
                                                                                                  |                                                                                  
                                              ---------------------------------------------------------------------------------------------------------                              
                                              |                                                                                |                      |                              
                                     additionalTerm [0]                                                             additionalOperator [0] multiplicativeTerm [0]                    
                                              |                                                                                |                      |                              
           -----------------------------------------------------------------------                                    "-"[unassigned] [0]        number [0]                          
           |                      |                                              |                                                                    |                              
  additionalTerm [0]   additionalOperator [0]                         multiplicativeTerm [0]                                                 "4"[unassigned] [0]                     
           |                      |                                              |                                                                                                   
multiplicativeTerm [0]   "+"[unassigned] [0]             -------------------------------------------------                                                                           
           |                                             |                        |                      |                                                                           
      number [0]                              multiplicativeTerm [0] multiplicativeOperator [0]     number [0]                                                                       
           |                                             |                        |                      |                                                                           
  "1"[unassigned] [0]                               number [0]           "/"[unassigned] [0]    "3"[unassigned] [0]                                                                  
                                                         |                                                                                                                           
                                                "2"[unassigned] [0]                                                                                                                  
      </pre>
      <p>
        <span class="line">
There are two problems with this approach.
        </span>
        <span class="line">
Firstly, the increased depth and complexity of the parse tree.
        </span>
        <span class="line">
Arguably extraneous nodes such as the <pre class="inline">multiplicativeTerm</pre> and <pre class="inline">additionalOperator</pre> nodes are an inevitable consequence of the elaborate BNF, for example.
        </span>
        <span class="line">
Seconldly, the BNF itself is flawed.
        </span>
        <span class="line">
Note that the <pre class="inline">multiplicativeTerm</pre> rule references the <pre class="inline">number</pre> rule, the reason being that there must be some rule at the foot of the hierarchy, so to speak.
        </span>
        <span class="line">
If we try to replace this with a reference to the <pre class="inline">term</pre> rule then we get a form of left recursion that cannot be eliminated.
        </span>
        <span class="line">
This is not a fault of the algorithm to eliminate left recusrion but a fault of the BNF itself.
        </span>
        <span class="line">
Thus is someone else wants to add additional rules to the <pre class="inline">term</pre> rule then they would be unable to do so independently.
        </span>
      </p>
      <p>
        <span class="line">
In order to tackle these problems a new way of treating precedence was devised.
        </span>
        <span class="line">
The BNF below shows all that is needed with the solution to hand:
        </span>
      </p>
      <pre class="block">
expression ::= term... "." ;


     term  ::=  argument ( "/" (4)
                            
                         | "*" (3)
                                            
                         | "+" (2)
               
                         | "-" (1) ) argument

             |  number

             ;
             
  argument ::= term ( ) 
  
             | type ( )
             
             ;

      
   number  ::=  /d+/ ; 
      </pre>
      <p>
        <span class="line">
Here each of the choices in the second part of the <pre class="inline">term</pre> rule's first definition has been augmented with a number in parenthesis.
        </span>
        <span class="line">
These numbers will be inherited by the nodes during parsing with the proviso that nodes with lower numbers are not allowed to appear directly below those with higher ones.
        </span>
        <span class="line">
And if look-ahead is enabled then the parser will have the chance to try likely several parse trees until it finds one that satisfies this criteria, thus enforcing precedence.
        </span>
      </p>
      <p>
        <span class="line">
One other thing to note is that both the definitions of the <pre class="inline">argument</pre> rule, the need for which will be explained in a later chapter, are given what might be called empty or see-through precedence.
        </span>
        <span class="line">
This ensures that precedence is enforced between nodes that are to be found directly above and below them.
        </span>
        <span class="line">
Here is the parse tree:
        </span>
      </p>
      <pre class="block">
                                                                                                              expression [0]                                   
                                                                                                                     |                                         
                                                                                    ------------------------------------------------------------------         
                                                                                    |                                                                |         
                                                                              term [0] (1)                                                  "."[unassigned] [0]
                                                                                    |                                                                          
                                       -------------------------------------------------------------------------------------------                             
                                       |                                                                     |                   |                             
                               argument [0] ( )                                                     "-"[unassigned] [0]  argument [0] ( )                      
                                       |                                                                                         |                             
                                 term [0] (2)                                                                                term [0]                          
                                       |                                                                                         |                             
         -------------------------------------------------------------                                                      number [0]                         
         |                   |                                       |                                                           |                             
 argument [0] ( )   "+"[unassigned] [0]                      argument [0] ( )                                           "4"[unassigned] [0]                    
         |                                                           |                                                                                         
     term [0]                                                  term [0] (4)                                                                                    
         |                                                           |                                                                                         
    number [0]                                   -----------------------------------------                                                                     
         |                                       |                   |                   |                                                                     
"1"[unassigned] [0]                      argument [0] ( )   "/"[unassigned] [0]  argument [0] ( )                                                              
                                                 |                                       |                                                                     
                                             term [0]                                term [0]                                                                  
                                                 |                                       |                                                                     
                                            number [0]                              number [0]                                                                 
                                                 |                                       |                                                                     
                                        "2"[unassigned] [0]                     "3"[unassigned] [0]                                                            
      </pre>
      <p>
        <span class="line">
In fairness it is deeper than the previous parse tree but this is only because of the requisite <pre class="inline">argument</pre> nodes.
        </span>
        <span class="line">
Other than that, note that precedence has been enforced with hardly any compromises on readability either of the parse tree or the BNF.
        </span>
        <span class="line">
Finally, note that it is possible to add further definitions to the <pre class="inline">term</pre> rule independently without introducting left recursion that cannot be eliminated.
        </span>
      </p>
      <h2>
        <span class="line">
 Left recursion
        </span>
      </h2>
      <p>
        <span class="line">
It helps to know what left recursion is because the algorithm to eliminate it will occasionally throw up an error that will appear spurious without context.
        </span>
        <span class="line">
We recall the following BNF:
        </span>
      </p>
      <pre class="block">
expression ::= "(" expression ")"
 
             | expression operator expression
 
             | number
 
             ;

  operator ::= "+" | "-" | "÷" | "×" ;

    number ::= /d+/ ;
      </pre>
      <p>
        <span class="line">
The second of the definitions of the <pre class="inline">expression</pre> rule is left recursive, as previously pointed out.
        </span>
        <span class="line">
Here is the adjusted BNF with the left recursion eliminated.
        </span>
        <span class="line">
It is certainly not necessary to understand how this can come about:
        </span>
      </p>
      <pre class="block">
expression            ::= expression_ expression~* ;

operator              ::= "+" | "-" | "÷" | "×" ;

number                ::= /d+/ ;

expression_           ::= "(" expression ")"

                        | number

                        ;

expression~expression ::= operator expression ;

expression~           ::= expression~expression ;
      </pre>
      <p>
        <span class="line">
However, we draw attention to one of the adjustments in order to justify the kinds of errors that result when certain forms of left recursion cannot be eliminated.
        </span>
        <span class="line">
Suppose then that the second definition is abridged:
        </span>
      </p>
      <pre class="block">
expression ::= "(" expression ")"

             | expression
 
             ...

             ;

...
      </pre>
      <p>
        <span class="line">
A little thought should convince that this will make the BNF untenable.
        </span>
        <span class="line">
The algorithm cannot be expected eliminate such forms of left recursion and therefore it will throw an error.
        </span>
        <span class="line">
The exact wording of the error may confuse, however:
        </span>
      </p>
      <pre class="block">
The 'expression~' directly repeated rule is effectively empty.
      </pre>
      <p>
        <span class="line">
Notice that the parts previously found after the <pre class="inline">expression</pre> part in the <pre class="inline">expression</pre> rule's second definition found their way verbatim into the single definition of the <pre class="inline">expresssion~expression</pre> rule.
        </span>
        <span class="line">
But with these parts removed, this rule becomes empty.
        </span>
        <span class="line">
And since the <pre class="inline">expression~</pre> rule references it, the former is described as being effectively empty.
        </span>
        <span class="line">
Thus a concrete feature of the adjusted BNF, in this case an empty rule, signifies a form of left recursion that cannot be eliminated.
        </span>
        <span class="line">
This is typical but fortunately there are only a handful of such forms and the errors that arise all follow along these lines.
        </span>
        <span class="line">
Furthermore, a little practice is all that suffices before it becomes straightforward to work out where problems lie.
        </span>
      </p>
      <p>
        <span class="line">
Lastly, the other type of error that arises is when complex parts cannot be rewritten.
        </span>
        <span class="line">
Again we alter the second definition of the <pre class="inline">expression</pre> rule to demonstrate:
        </span>
      </p>
      <pre class="block">
expression ::= "(" expression ")"

             | ( expression | number ) operator expression

             ...

             ;
 
...
      </pre>
      <p>
        <span class="line">
The first part of the second definition is a complex part and these cannot be rewritten.
        </span>
        <span class="line">
To see what this is so, simply ask yourself what the names of the rewritten rules would be.
        </span>
        <span class="line">
Here is the error:
        </span>
      </p>
      <pre class="block">
The '( expression | expression ) operator expression' definition of the 'expression' rule is complex.
      </pre>
      <p>
        <span class="line">
In these cases there is no choice but to pull the offending complex part out into its own rule:
        </span>
      </p>
      <pre class="block">
      expression ::= "(" expression ")"

                   | expressionNumber operator expression

                   ...

                   ;

expressionNumber ::= expression | number ;

...
      </pre>
      <p>
        <span class="line">
Now rules such as <pre class="inline">expressionNumber~</pre> can be created by the algorithm.
        </span>
        <span class="line">
Finally on this subject it is worth noting that When complex part errors arise experience suggests that they can often be replaced with something better rather than pulling them out into another rule.
        </span>
      </p>
      <ol class="footnotes">
        <li class="footnote">
          <a class="anchor" id="regular-expressions"/>
          <p>
            <span class="line">
<a href="https://en.wikipedia.org/wiki/Regular_expression">https://en.wikipedia.org/wiki/Regular_expression</a>
            </span>
          </p>
        </li>
        <li class="footnote">
          <a class="anchor" id="bnf"/>
          <p>
            <span class="line">
<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">https://en.wikipedia.org/wiki/Backus-Naur_form</a>
            </span>
          </p>
        </li>
        <li class="footnote">
          <a class="anchor" id="juliamono"/>
          <p>
            <span class="line">
<a href="https://juliamono.netlify.app">https://juliamono.netlify.app</a>/
            </span>
          </p>
        </li>
        <li class="footnote">
          <a class="anchor" id="occam-grammars"/>
          <p>
            <span class="line">
<a href="https://github.com/djalbat/occam-grammars">https://github.com/djalbat/occam-grammars</a>
            </span>
          </p>
        </li>
      </ol>
    </div>
  </div>


  </body>
</html>
